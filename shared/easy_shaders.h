static char *frag_model_shader = "uniform sampler2D normalMap;\n"
"in vec4 colorOut;\n"
"in vec2 texUV_out;\n"
"\n"
"struct Material {\n"
"    sampler2D diffuse;\n"
"    sampler2D specular;\n"
"    float shininess;\n"
"};\n"
"\n"
"struct DirLight {\n"
"	V3 ambient;\n"
"	V3 diffuse;\n"
"	V3 specular;\n"
"\n"
"	V3 direction;\n"
"};\n"
"\n"
"vec4 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir, V4 colorShade)\n"
"{\n"
"    vec3 lightDir = normalize(-light.direction);\n"
"    \n"
"    // diffuse shading\n"
"    float diff = max(dot(normal, lightDir), 0.0);\n"
"\n"
"    // specular shading\n"
"    vec3 reflectDir = reflect(-lightDir, normal);\n"
"    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n"
"    // combine results	\n"
"    V4 diffTex = texture(material.diffuse, texUV_out);\n"
"    V4 specTex = texture(material.specular, texUV_out);\n"
"\n"
"    V4 ambColor = (diffTex*colorShade)*diffTex.w;\n"
"    V4 diffColor = ambColor\n"
"    V4 specColor = (specTex*colorShade)*specTex.w;\n"
"\n"
"    vec4 ambient  = light.ambient  * ambColor\n"
"    vec4 diffuse  = light.diffuse  * diff * diffColor;\n"
"    vec4 specular = light.specular * spec * specColor;\n"
"    return (ambient + diffuse + specular);\n"
"}  \n"
"\n"
"// vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)\n"
"// {\n"
"//     vec3 lightDir = normalize(light.position - fragPos);\n"
"//     // diffuse shading\n"
"//     float diff = max(dot(normal, lightDir), 0.0);\n"
"//     // specular shading\n"
"//     vec3 reflectDir = reflect(-lightDir, normal);\n"
"//     float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n"
"//     // attenuation\n"
"//     float distance    = length(light.position - fragPos);\n"
"//     float attenuation = 1.0 / (light.constant + light.linear * distance + \n"
"//   			     light.quadratic * (distance * distance));    \n"
"//     // combine results\n"
"//     vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));\n"
"//     vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));\n"
"//     vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));\n"
"//     ambient  *= attenuation;\n"
"//     diffuse  *= attenuation;\n"
"//     specular *= attenuation;\n"
"//     return (ambient + diffuse + specular);\n"
"// } \n"
"\n"
"out vec4 color;\n"
"void main (void) {\n"
"    vec4 normal = texture(normalMap, texUV_out);\n"
"    \n"
"    vec4 b = colorOut*colorOut.w;\n"
"\n"
"    vec3 lightingColor = CalcDirLight(light, normal.xyz, v3(0, 0, -1), b);\n"
"    color = vec4(lightingColor, 1);\n"
"}";

static char *fragment_shader_texture_shader = "uniform sampler2D tex;\n"
"in vec4 colorOut;\n"
"in vec2 texUV_out;\n"
"\n"
"out vec4 color;\n"
"void main (void) {\n"
"	vec4 texColor = texture(tex, texUV_out);\n"
"	float alpha = texColor.w;\n"
"	if(alpha == 0) discard; \n"
"	vec4 b = colorOut*colorOut.w;\n"
"	vec4 c = b*texColor;\n"
"	c *= alpha;\n"
"    color = c;\n"
"}";

static char *vertex_model_shader = "in mat4 VM;\n"
"in mat4 P;\n"
"in vec4 color;\n"
"in vec4 uvAtlas;	\n"
"\n"
"in vec3 vertex;\n"
"in vec2 texUV;	\n"
"\n"
"out vec4 colorOut; //out going\n"
"out vec2 texUV_out;\n"
"\n"
"// uniform vec4 color;\n"
"\n"
"in vec3 vertex;\n"
"// in vec2 texUV;\n"
"// in vec3 normal;\n"
"//in int instanceIndex;\n"
"\n"
"// out vec4 colorOut; //out going\n"
"// out vec2 texUV_out;\n"
"\n"
"void main() {\n"
"    gl_Position = perspective * view * model * vec4(vertex, 1);\n"
"    // colorOut = texelFetch(ColorArray, gl_InstanceID);\n"
"    // texUV_out = texUV;\n"
"}";

static char *vertex_shader_tex_attrib_shader = "in mat4 VM;\n"
"in mat4 P;\n"
"in vec4 color;\n"
"in vec4 uvAtlas;	\n"
"\n"
"in vec3 vertex;\n"
"in vec2 texUV;	\n"
"\n"
"out vec4 colorOut; //out going\n"
"out vec2 texUV_out;\n"
"\n"
"void main() {\n"
"    \n"
"    gl_Position = P * VM * vec4(vertex, 1);\n"
"    colorOut = color;\n"
"    \n"
"    int xAt = int(texUV.x*2);\n"
"    int yAt = int(texUV.y*2) + 1;\n"
"    texUV_out = vec2(uvAtlas[xAt], uvAtlas[yAt]);\n"
"}";

